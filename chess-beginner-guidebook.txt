import pygame
import chess
import random
import sys

# === 전역 변수 설정 ===

# === 화면 및 렌더링 관련 변수 ===
screen = None  # Pygame의 메인 디스플레이 Surface 객체
font = None    # 텍스트 출력용 폰트 객체
clock = None   # FPS 제어용 Pygame Clock 객체

# === 체스 보드 및 기물 상태 ===
board = None                      # 현재 체스 보드 상태 (chess.Board 객체)
selected = None                   # 선택한 기물의 위치 (square index)
legal_moves_for_selected = []     # 선택한 기물의 합법적 이동 리스트
capture_squares = []              # 잡을 수 있는 기물 위치 목록
last_move = None                  # 마지막으로 실행한 move 객체
move_log = []                     # 이동 기록 (SAN 형식)
puzzle_turn = None                # 퍼즐 시작 시 턴 정보 (WHITE 또는 BLACK)
selected_piece_symbol = None     # 프로모션 시 선택한 기물 기호 (e.g., 'Q')
pending_promotion = None         # 프로모션 대기 중인 상태

# === 퍼즐 관리 변수 ===
filtered_puzzles = []                 # 현재 유형에 해당하는 퍼즐 리스트
current_puzzle_type = None           # 선택된 퍼즐 유형 이름
solved_history_by_type = {           # 유형별 정답 퍼즐 기록
    "1수 체크메이트": [],
    "핀": [],
    "포크": [],
    "공짜 기물 잡기": [],
    "스큐어": [],
    "랜덤": []
}
current_random_index = 0             # 랜덤 퍼즐용 현재 인덱스
used_puzzle_order = []               # 이미 시도한 퍼즐 인덱스 저장

# === 버튼 UI 요소 ===
puzzle_button = None           # 시작 화면의 "연습문제" 버튼 위치
reset_button_rect = None       # 퍼즐 화면의 "다시 풀기" 버튼 위치
prev_button_rect = None        # 퍼즐 화면의 "이전" 버튼 위치
next_button_rect = None        # 퍼즐 화면의 "다음" 버튼 위치
back_button_rect = None        # 퍼즐 화면의 "뒤로가기" 버튼 위치

# === 상태 메시지 및 설명 ===
status_message = ""                # 정답/오답 등 상태 메시지
special_rule_description = ""     # 특수 규칙 체험 설명 텍스트

# === 화면 및 색상 설정 ===
WIDTH = 740
HEIGHT = 512
SQUARE_SIZE = 512 // 8
MOVE_LOG_WIDTH = 128
FONT_SIZE = 18

WHITE = (240, 217, 181)
BROWN = (181, 136, 99)
DOT_COLOR = (100, 100, 100)
ATTACK_DOT_COLOR = (200, 50, 50)
HIGHLIGHT_COLOR = (255, 255, 100)
BLACK = (0, 0, 0)
BG_COLOR = (255, 255, 255)
BUTTON_COLOR = (200, 200, 200)
CAPTURE_BORDER_COLOR = (128, 128, 128)

# === 퍼즐 목록 === ctrl + /
PUZZLES = [
    #1수 체크메이트
    {"fen": "r1bqkb1r/2pppp1p/pp6/6N1/2Q1P1n1/2N5/PPP2PPP/R1B1KB1R w KQkq - 0 8", "goal": "checkmate", "type": "1수 체크메이트",
     "explanation": "퀸이 f7폰을 잡으면서 체크메이트. 킹은 움직일수 있는 칸이 없고, 퀸은 나이트에게 지켜지고 있습니다."},
    {"fen": "3q2rk/Q3R2p/3p1p1p/3r4/8/1P3N1b/P1P2PP1/4R1K1 w - - 0 24", "goal": "checkmate", "type": "1수 체크메이트",
     "explanation": "룩이 h7폰을 잡으면서 체크메이트. 킹이 이동할 수 있는 곳은 룩과 퀸이 막고 있으며 룩은 퀸에게 지켜지고 있습니다."},
    {"fen": "r1b1r3/2pk1p1Q/p2p4/1p4b1/6P1/1BN5/PP3q2/R2K3R b - - 1 23", "goal": "checkmate", "type": "1수 체크메이트",
     "explanation": "퀸이 d2칸으로 이동하며 체크메이트. 킹이 이동할 수 있는 곳은 모두 퀸이 막고 있으며 퀸은 비숍에게 지켜지고 있습니다."},
    {"fen": "3R4/kpp1r3/p6p/5b2/2N5/2P5/PP1Kp1PP/5N2 b - - 3 30","goal": "checkmate", "type": "1수 체크메이트",
     "explanation": "폰이 퀸으로 승진하며 체크메이트. 킹이 이동할 수 있는 곳은 퀸과 비숍이 막고 있으며 퀸은 룩에게 지켜지고 있습니다."},
    {"fen": "6k1/2p2p1p/p5p1/4r3/P1Pbq3/1Q1p2P1/6RK/5N2 b - - 3 31", "goal": "checkmate", "type": "1수 체크메이트",
     "explanation": "룩이 h5칸으로 이동하며 체크메이트. 킹이 이동할 수 있는 곳은 룩과 비숍이 막고 있습니다."},
    {"fen": "6R1/1r3p1k/p4p1p/4pn1N/2P3R1/PP4P1/5PKP/8 w - - 2 40", "goal": "checkmate", "type": "1수 체크메이트",
     "explanation": "나이트가 f6폰을 잡으면서 체크메이트. 킹이 이동할 수 있는 곳은 룩이 막고 있으며 룩은 나이트에게 지켜지고 있습니다."},
    {"fen": "5rk1/1pp2pp1/6Pp/1p2p3/1P2B3/BQ6/2P3PP/q4R1K b - - 0 22", "goal": "checkmate", "type": "1수 체크메이트",
     "explanation": "퀸이 f1룩을 잡으면서 체크메이트. 킹이 이동할 수 있는 곳은 퀸이 막고 있습니다."},
    {"fen": "2r3k1/ppp2p2/2n4p/2P3p1/1P6/P1P2p1n/3r1B1P/2RBRK2 b - - 1 27", "goal": "checkmate", "type": "1수 체크메이트",
     "explanation": "룩이 f2비숍을 잡으면서 체크메이트. 킹이 이동할 수 있는 곳은 폰과 나이트가 막고 있으며 룩은 나이트에게 지켜지고 있습니다."},
    {"fen": "5rk1/2p2ppp/p3b3/4p1P1/4P2P/P1N4q/1PBn1P2/R1n3K1 b - - 7 33", "goal": "checkmate", "type": "1수 체크메이트",
     "explanation": "나이트가 f3칸으로 이동하며 체크메이트. 킹이 이동할 수 있는 곳은 퀸이 막고 있습니다."},
    {"fen": "7Q/6p1/4pk1p/4N3/3P3P/8/5PPK/qq6 w - - 4 47", "goal": "checkmate", "type": "1수 체크메이트",
     "explanation": "퀸이 f8칸으로 이동하며 체크메이트. 킹이 이동할 수 있는 곳은 퀸, 나이트, 폰이 막고 있으며 나이트는 폰에게 지켜지고 있습니다."},
    
    # 포크
    {"fen": "rn1q1rk1/pbp1bppp/1p6/3np3/4N1Q1/3P2P1/PPPB1PBP/R3K1NR b KQ - 5 9", "goal": "fork", "solution": "f5", "type": "포크",
     "explanation": "폰으로 퀸과 나이트를 동시에 공격합니다. 폰은 룩의 보호를 받고 있어 안전합니다."},
    {"fen": "2kr1bnr/ppp2ppp/4p3/3q1b2/3P2B1/5PP1/PP2P2P/RNBQ1RK1 w - - 1 11", "goal": "fork", "solution": "e4", "type": "포크",
     "explanation": "폰으로 퀸과 비숍을 동시에 공격합니다. 폰은 폰의 보호를 받고 있어 안전합니다."},
    {"fen": "6R1/5pp1/4pk1p/p7/P7/2r3P1/3N1P1P/6K1 w - - 4 32", "goal": "fork", "solution": "Ne4", "type": "포크",
     "explanation": "나이트로 킹과 룩을 동시에 공격합니다."},
    {"fen": "6k1/ppb1p2p/4pr2/2P1n3/2PN1R1K/1P5P/P2B2P1/3N4 b - - 0 30", "goal": "fork", "solution": "Ng6+", "type": "포크",
     "explanation": "나이트로 킹과 룩을 동시에 공격합니다."},
    {"fen": "3rr1k1/p2b1p2/1p4pp/8/6Pn/PBP1BR2/1P3P1P/R5K1 w - - 1 25", "goal": "fork", "solution": "Bxf7+", "type": "포크",
     "explanation": "비숍으로 킹과 룩을 동시에 공격합니다. 비숍은 룩의 보호를 받고 있어 안전합니다."},
    {"fen": "2kr1b1r/pbp2Bp1/1p5p/4p3/4P1n1/2P1RN2/PP1N1PPP/2R3K1 w - - 1 16", "goal": "fork", "solution": "Be6+", "type": "포크",
     "explanation": "비숍으로 킹과 나이트를 동시에 공격합니다."},
    {"fen": "7k/1p4p1/7p/pP1PP1bP/P3K1B1/8/5r2/4R3 b - - 2 37", "goal": "fork", "solution": "Rf4+", "type": "포크",
     "explanation": "룩으로 킹과 비숍을 동시에 공격합니다. 룩은 비숍의 보호를 받고 있어 안전합니다."},
    {"fen": "2r4r/1p5p/p3kp1b/3Np1p1/4P3/4R3/PPP2RPP/2K5 w - - 4 23", "goal": "fork", "solution": "Rxf6+", "type": "포크",
     "explanation": "룩으로 킹과 비숍을 동시에 공격합니다. 룩은 나이트의 보호를 받고 있어 안전합니다."},
    {"fen": "r1b2r2/ppq1ppkp/3p2p1/1B1P4/1n6/1P3N2/P1P2PPP/2RQR1K1 w - - 1 16", "goal": "fork", "solution": "Qd4+", "type": "포크",
     "explanation": "퀸으로 킹과 나이트를 동시에 공격합니다."},
    {"fen": "5rk1/p1pp1pp1/1p5p/1P3P2/bqP1N1P1/4QN2/R3K1BP/8 b - - 0 32", "goal": "fork", "solution": "Qxc4+", "type": "포크",
     "explanation": "퀸으로 킹과 룩을 동시에 공격합니다."},
    
    # 핀
    {"fen": "r1q2rk1/3b1ppp/p2p1b2/1ppP1P2/4P3/P1N1Q3/1PP1B1PP/1R3RK1 b - - 2 17", "goal": "pin", "solution": "Bd4", "type": "핀",
     "explanation": "비숍이 폰의 보호를 받으며 퀸을 핀에 걸었습니다. 비숍은 폰의 보호를 받고있고, 퀸은 뒤에 킹이 있기 때문에 움직일 수 없습니다."},
    {"fen": "r1b2rk1/1pp2ppp/p4bn1/3q4/B2P4/2P2N2/PP3PPP/R1BQR1K1 b - - 4 14", "goal": "pin", "solution": "Bg4", "type": "핀",
     "explanation": "비숍이 나이트를 핀에 걸었습니다. 나이트가 움직이면 뒤에 있는 퀸이 잡히게 되므로 쉽게 움직일 수 없습니다."},
    {"fen": "rnbqkb1r/ppp2ppp/8/3pP3/3Pn3/2N5/PPP3PP/R1BQKBNR b KQkq - 0 5", "goal": "pin", "solution": "Bb4", "type": "핀",
     "explanation": "비숍이 나이트를 핀에 걸었습니다. 나이트는 뒤에 킹이 있기 때문에 움직일 수 없습니다."},
    {"fen": "8/2p5/8/2b1R2P/5K2/3k4/6r1/8 b - - 4 47", "goal": "pin", "solution": "Bd6", "type": "핀",
     "explanation": "비숍이 룩을 핀에 걸었습니다. 룩은 뒤에 킹이 있기 때문에 움직일 수 없습니다."},
    {"fen": "r2qkb1r/pp2pppp/2n2n2/8/3P2b1/5N2/PPP2PPP/RNBQKB1R w KQkq - 1 6", "goal": "pin", "solution": "Bb5", "type": "핀",
     "explanation": "비숍이 나이트를 핀에 걸었습니다. 나이트는 뒤에 킹이 있기 때문에 움직일 수 없습니다."},
    {"fen": "r1bqr1k1/pp3p1p/6p1/3nP2P/8/8/PPP1B1P1/R1BQK2R b KQ - 2 16", "goal": "pin", "solution": "Rxe5", "type": "핀",
     "explanation": "룩이 폰을 잡으며 비숍을 핀에 걸었습니다. 비숍은 뒤에 킹이 있기 때문에 움직일 수 없습니다."},
    {"fen": "r2qr1k1/pp3ppp/3b1n2/1NpP4/8/1Q4P1/PP1P1P1P/R1B2BK1 b - - 0 16", "goal": "pin", "solution": "Re1", "type": "핀",
     "explanation": "룩이 비숍을 핀에 걸었습니다. 비숍은 뒤에 킹이 있기 때문에 움직일 수 없습니다."},
    {"fen": "8/8/3pk2B/2p5/4b3/P1P5/3R1PPP/6K1 w - - 1 31", "goal": "pin", "solution": "Re2", "type": "핀",
     "explanation": "룩이 비숍을 핀에 걸었습니다. 비숍은 뒤에 킹이 있기 때문에 움직일 수 없습니다."},
    {"fen": "r2k1b1r/pppnn1pp/5p2/4p3/2B1P3/5N2/PPP2PPP/R1B2RK1 w - - 2 10", "goal": "pin", "solution": "Rd1", "type": "핀",
     "explanation": "룩이 나이트를 핀에 걸었습니다. 나이트는 뒤에 킹이 있기 때문에 움직일 수 없습니다."},
    {"fen": "3R4/3R4/4q1kp/p3rpp1/Pp6/1P4P1/5PKP/8 w - - 4 36", "goal": "pin", "solution": "Rd6", "type": "핀",
     "explanation": "룩이 퀸을 핀에 걸었습니다. 룩은 룩의 보호를 받고있고, 퀸은 뒤에 킹이 있기 때문에 움직일 수 없습니다."},
    
    # 공짜 기물 잡기
    {"fen": "rnbq1rk1/ppp2pbp/6p1/3Pp3/2P1P1n1/2N1BN2/PP4PP/R2QKB1R b KQ - 2 9", "goal": "hanging", "solution": "Nxe3", "type": "공짜 기물 잡기",
     "explanation": "나이트가 지켜지지 않고 있는 비숍을 잡았습니다."},
    {"fen": "r3k3/1p4p1/p1p1pp2/4B3/3P2p1/4R3/PPP2n1r/2K2R2 w q - 0 20", "goal": "hanging", "solution": "Bxh2", "type": "공짜 기물 잡기",
     "explanation": "비숍이 지켜지지 않고 있는 룩을 잡았습니다."},
    {"fen": "4r1k1/1b1R1pp1/p1q4p/1p6/2p1p3/P1P2P1P/1PB1Q1P1/6K1 b - - 0 25", "goal": "hanging", "solution": "Qxd7", "type": "공짜 기물 잡기",
     "explanation": "퀸이 지켜지지 않고 있는 룩을 잡았습니다."},
    {"fen": "r1b2rk1/pp3pbp/2p3p1/4p1Bn/R1N1P3/1qP2Q1N/1P3PPP/5RK1 b - - 1 15", "goal": "hanging", "solution": "Qxa4", "type": "공짜 기물 잡기",
     "explanation": "퀸이 지켜지지 않고 있는 룩을 잡았습니다."},
    {"fen": "5rk1/p3Qppp/7n/2q1p3/K7/6P1/PP5P/8 w - - 0 31", "goal": "hanging", "solution": "Qxc5", "type": "공짜 기물 잡기",
     "explanation": "퀸이 지켜지지 않고 있는 퀸을 잡았습니다."},
    {"fen": "4r1k1/1bq2p2/r4Q1p/3p4/3Pp3/2P5/1PB2PPP/1R3RK1 b - - 0 21", "goal": "hanging", "solution": "Rxf6", "type": "공짜 기물 잡기",
     "explanation": "룩이 지켜지지 않고 있는 퀸을 잡았습니다."},
    {"fen": "8/k3q3/ppr5/3Q4/P2Bp3/4PnP1/1R2K3/8 w - - 13 53", "goal": "hanging", "solution": "Qxc6", "type": "공짜 기물 잡기",
     "explanation": "퀸이 지켜지지 않고 있는 룩을 잡았습니다."},
    {"fen": "r2q1rk1/4ppbp/4b1p1/1N6/2pPn1P1/4BN1P/2Q2P2/1RR3K1 w - - 1 27", "goal": "hanging", "solution": "Qxe4", "type": "공짜 기물 잡기",
     "explanation": "퀸이 지켜지지 않고 있는 나이트를 잡았습니다."},
    {"fen": "r3rnk1/pR3p2/2p2npp/3p1b2/3Q1P2/2P4P/2qN1BP1/5RK1 w - - 0 22", "goal": "hanging", "solution": "Qxf6", "type": "공짜 기물 잡기",
     "explanation": "퀸이 지켜지지 않고 있는 나이트를 잡았습니다."},
    {"fen": "r3k1nr/pppb1ppp/8/1N2b3/3p1P2/3B4/PPP3PP/R1B1K2R w KQkq - 1 11", "goal": "hanging", "solution": "fxe5", "type": "공짜 기물 잡기",
     "explanation": "폰이 지켜지지 않고 있는 비숍을 잡았습니다."},
    
    # 스큐어
    {"fen": "r1b4r/ppp4p/5k2/8/4p3/8/P5PP/RNB3K1 w - - 0 20", "goal": "skewer", "solution": "Bb2+", "type": "스큐어",
     "explanation": "비숍이 b2칸으로 이동하며 스큐어를 걸었습니다. 킹이 움직이면 뒤에있는 룩이 잡히게 됩니다."},
    {"fen": "8/2Q2pp1/4bk1p/8/5P1q/8/6P1/6K1 w - - 6 32", "goal": "skewer", "solution": "Qd8+", "type": "스큐어",
     "explanation": "퀸이 d8칸으로 이동하며 스큐어를 걸었습니다. 킹이 움직이면 뒤에있는 퀸이 잡히게 됩니다."},
    {"fen": "2k4r/2r2p2/p2p1p2/1Qp2P2/3pP2p/3Pb2P/2P1B1q1/1R1K1R2 w - - 0 26", "goal": "skewer", "solution": "Qb8+", "type": "스큐어",
     "explanation": "퀸이 b8칸으로 이동하며 스큐어를 걸었습니다. 킹이 움직이면 뒤에있는 룩이 잡히게 됩니다."},
    {"fen": "3r3k/R6P/3p2B1/1p1P2b1/3r4/P5K1/1PP3P1/4R3 b - - 6 34", "goal": "skewer", "solution": "Bh4+", "type": "스큐어",
     "explanation": "비숍이 h4칸으로 이동하며 스큐어를 걸었습니다. 비숍은 룩의 보호를 받고 있고, 킹이 움직이면 뒤에있는 룩이 잡히게 됩니다."},
    {"fen": "2k5/8/8/5P2/5KQ1/2P1r3/PP2r3/8 b - - 4 78", "goal": "skewer", "solution": "Re4+", "type": "스큐어",
     "explanation": "룩이 e4칸으로 이동하며 스큐어를 걸었습니다. 룩은 룩의 보호를 받고 있고, 킹이 움직이면 뒤에있는 퀸이 잡히게 됩니다."},
    {"fen": "6k1/p5pp/6b1/8/6P1/1PK2PbN/8/R7 b - - 0 33", "goal": "skewer", "solution": "Be5+", "type": "스큐어",
     "explanation": "비숍이 e5칸으로 이동하며 스큐어를 걸었습니다. 킹이 움직이면 뒤에있는 룩이 잡히게 됩니다."},
    {"fen": "r2q1rk1/p2Bn1pp/1ppbPp2/3p3b/3P4/2PQ1N1P/P4PP1/1RB1R1K1 b - - 1 17", "goal": "skewer", "solution": "Bg6", "type": "스큐어",
     "explanation": "비숍이 g6칸으로 이동하며 스큐어를 걸었습니다. 퀸이 움직이면 뒤에있는 룩이 잡히게 됩니다."},
    {"fen": "6r1/1pq3k1/p6R/6P1/1P6/2PBbN2/P5K1/8 w - - 1 41", "goal": "skewer", "solution": "Rh7+", "type": "스큐어",
     "explanation": "룩이 h7칸으로 이동하며 스큐어를 걸었습니다. 룩은 비숍의 보호를 받고 있고, 킹이 움직이면 뒤에있는 퀸이 잡히게 됩니다."},
    {"fen": "rn2k2r/pp3ppp/2pqpn2/5b2/3P4/2P2QP1/PP2NP1P/R1B1KB1R b KQkq - 0 9", "goal": "skewer", "solution": "Be4", "type": "스큐어",
     "explanation": "비숍이 e4칸으로 이동하며 스큐어를 걸었습니다. 비숍은 나이트의 보호를 받고 있고, 퀸이 움직이면 뒤에있는 룩이 잡히게 됩니다."},
    {"fen": "8/7R/p2k2r1/1p1Pp2p/5r2/8/7P/K1R5 w - - 0 38", "goal": "skewer", "solution": "Rc6+", "type": "스큐어",
     "explanation": "룩이 c6칸으로 이동하며 스큐어를 걸었습니다. 룩은 폰의 보호를 받고 있고, 킹이 움직이면 뒤에있는 룩이 잡히게 됩니다."}
]
puzzle_order = random.sample(range(len(PUZZLES)), len(PUZZLES))
current_puzzle_index = puzzle_order.pop(0)

# === 기물 설명 ===
PIECE_DESCRIPTIONS = {
    "P": "폰 : 기물점수 1점 \n앞으로 한 칸 전진합니다. \n첫 회 한정으로 두 칸 전진할 수 있습니다. \n공격은 앞 쪽 대각선으로만 가능합니다. \n마지막 랭크에 도달시, 프로모션이 가능합니다.",
    "K": "킹 \n모든 방향으로 한 칸만 이동합니다.",
    "Q": "퀸 : 기물점수 9점 \n모든 방향으로 자유롭게 이동합니다.",
    "R": "룩 : 기물점수 5점 \n전후좌우 직선으로 이동합니다.",
    "B": "비숍 : 기물점수 3점 \n대각선 방향으로 이동합니다.",
    "N": "나이트 : 기물점수 3점 \nL자 모양으로 이동합니다. \n유일하게 기물을 뛰어넘어 이동할 수 있습니다.",
}

# === 기물 힌트 ===
TACTIC_HINTS = {
    "1수 체크메이트": "한 수 만에 체크메이트를 만들어보세요!",
    "핀": "기물을 핀에 걸어보세요! (상대의 중요한 기물이 뒤에 있습니다.)",
    "포크": "하나의 기물로 두 개의 기물을 동시에 공격해보세요!",
    "공짜 기물 잡기": "지켜지지 않은 기물을 잡아보세요!",
    "스큐어": "가치가 높은 기물을 먼저 공격해서 뒤에 있는 기물을 노리세요!",
    "랜덤": "체크메이트 또는 전술 기회를 찾아보세요!"
}

# 체스 기물 이미지 불러오기 함수
def load_images():
    mapping = {
        'P': 'WP', 'N': 'WN', 'B': 'WB', 'R': 'WR', 'Q': 'WQ', 'K': 'WK',
        'p': 'BP', 'n': 'BN', 'b': 'BB', 'r': 'BR', 'q': 'BQ', 'k': 'BK'
    }
    images = {}
    for symbol, filename in mapping.items():
        path = f"pieces/{filename}.png"
        try:
            images[symbol] = pygame.transform.scale(
                pygame.image.load(path),
                (SQUARE_SIZE, SQUARE_SIZE)
            )
        except Exception as e:
            print(f"[ERROR] {path}: {e}")
    return images

# 시작 화면을 보여주는 함수
def show_start_screen():
    global puzzle_button, board, selected, legal_moves_for_selected, capture_squares
    global last_move, move_log, pending_promotion, selected_piece_symbol, special_rule_description

    # --- 상태 초기화 ---
    board = chess.Board()
    
    selected = None
    legal_moves_for_selected = []
    capture_squares = []
    last_move = None
    move_log = []
    pending_promotion = None
    selected_piece_symbol = None
    special_rule_description = ""

    images = load_images()

    # 버튼 위치 설정
    howto_button = pygame.Rect(520, HEIGHT - 110, 200, 40)
    puzzle_button = pygame.Rect(520, HEIGHT - 50, 200, 40)

    while True:
        screen.fill(BG_COLOR)
        draw_board()
        draw_pieces(images)

        # 제목
        title = font.render("체스 입문자용 가이드북", True, BLACK)
        screen.blit(title, (530, 10))

        draw_button_with_text(howto_button, "체스 방법", font)
        draw_button_with_text(puzzle_button, "연습 문제", font)

        pygame.display.flip()

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if howto_button.collidepoint(event.pos):
                    show_howto_screen()
                    return
                elif puzzle_button.collidepoint(event.pos):
                    show_puzzle_category_screen()
                    return

        clock.tick(60)

# 글자 줄바꿈 함수
def wrap_text_by_pixel(text, font, max_width):
    words = text.split(' ')
    lines = []
    current_line = ""

    for word in words:
        test_line = current_line + (" " if current_line else "") + word
        width, _ = font.size(test_line)
        if width <= max_width:
            current_line = test_line
        else:
            if current_line:
                lines.append(current_line)
            current_line = word

    if current_line:
        lines.append(current_line)

    return lines

# 버튼 그리기 함수
def draw_button_with_text(rect, text, font, text_color=BLACK):
    # 버튼 배경
    pygame.draw.rect(screen, BUTTON_COLOR, rect)
    # 버튼 테두리
    pygame.draw.rect(screen, BLACK, rect, 2)
    # 텍스트 렌더링
    text_surface = font.render(text, True, text_color)
    text_rect = text_surface.get_rect(center=rect.center)  # 버튼 안 중앙 정렬
    screen.blit(text_surface, text_rect)

##체스방법##

# 체스 방법 설명 화면 표시 함수
def show_howto_screen():
    global back_button_rect
    while True:
        back_button_rect = pygame.Rect(20, HEIGHT - 50, 80, 30)
        screen.fill(BG_COLOR)
        title = font.render("체스 방법 안내", True, BLACK)
        screen.blit(title, (WIDTH // 2 - title.get_width() // 2, 40))

        howto_buttons = {
            "기본 규칙": pygame.Rect(270, 100, 200, 40),
            "체스 기물": pygame.Rect(270, 160, 200, 40),
            "특수 규칙": pygame.Rect(270, 220, 200, 40),
            "전술 용어": pygame.Rect(270, 280, 200, 40),
        }
        for label, rect in howto_buttons.items():
            pygame.draw.rect(screen, BUTTON_COLOR, rect)
            pygame.draw.rect(screen, BLACK, rect, 2)
            text = font.render(label, True, BLACK)
            text_rect = text.get_rect(center=rect.center)
            screen.blit(text, text_rect)

        draw_button_with_text(back_button_rect, "뒤로", font)

        pygame.display.flip()

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if back_button_rect.collidepoint(event.pos):
                    return True

                for label, rect in howto_buttons.items():
                    if rect.collidepoint(event.pos):
                        if label == "기본 규칙":
                            show_howto_detail(label)
                        elif label == "체스 기물":
                            show_piece_guide_board()
                        elif label == "특수 규칙":
                            show_special_rule_board()
                        elif label == "전술 용어":
                            show_tactic_guide_board()

# 선택된 체스 설명 항목을 보여주는 함수
def show_howto_detail(title_text):
    global back_button_rect
    back_button_rect = pygame.Rect(20, HEIGHT - 50, 80, 30)

    screen.fill(BG_COLOR)

    content_map = {
        "기본 규칙": [
            "1. 체스는 두 명이 번갈아 한 수씩 두는 게임입니다.",
            "2. 백(흰색)이 먼저 시작합니다.",
            "3. 각 턴에는 반드시 자신의 기물 중 하나만 움직일 수 있습니다.",
            "4. 상대 기물이 있는 칸으로 이동하면 그 기물을 잡을 수 있습니다.",
            "5. 킹이 공격받는 상태를 '체크'라고 하며, 반드시 체크에서 벗어나는 수를 두어야 합니다.",
            "6. 체크에서 벗어날 방법이 없으면 '체크메이트'로 게임이 끝나고, 체크메이트한 쪽이 승리합니다.",
            "7. 특수 규칙: 폰의 '프로모션', '앙파상', 킹과 룩이 함께 움직이는 '캐슬링' 등이 있습니다. (특수 규칙에서 확인 가능)",
            "8. 무승부가 되는 경우도 있습니다. (예: 스테일메이트, 50수 규칙, 3회 동형 반복, 기물 부족 등).",
        ],
    }

    # 제목
    header = font.render(title_text, True, BLACK)
    screen.blit(header, (WIDTH // 2 - header.get_width() // 2, 30))

    # 본문 출력 (픽셀 기준 자동 줄바꿈 + 문단 개행 처리)
    y = 70
    max_width = 600  # 필요 시 레이아웃에 맞춰 조정 (예: WIDTH - 좌우여백)

    for line in content_map.get(title_text, []):
        # 문장 내 수동 개행(\n) 먼저 분리 → 각 문단을 wrap
        paragraphs = line.split('\n')
        for para in paragraphs:
            wrapped_lines = wrap_text_by_pixel(para, font, max_width)
            for wrapped in wrapped_lines:  # ← 들여쓰기 중요!
                line_surface = font.render(wrapped, True, BLACK)
                screen.blit(line_surface, (60, y))
                y += FONT_SIZE + 6  # 줄 간격
        y += 10  # 문단 간격

    # "체스 기물" 상세로 들어가야 하는 경우 (현재는 기본 규칙 화면이므로 보통 필요 없음)
    if title_text == "체스 기물":
        show_piece_guide_board()
        return

    # 뒤로 버튼
    draw_button_with_text(back_button_rect, "뒤로", font)
    pygame.display.flip()

    # 이벤트 루프
    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if back_button_rect.collidepoint(event.pos):
                    return

#체스기물#

# 체스방법 → 체스기물
def show_piece_guide_board():
    global board, selected_piece_symbol, selected, legal_moves_for_selected, capture_squares, last_move, special_rule_description
    selected_piece_symbol = None
    selected = None
    legal_moves_for_selected = []
    capture_squares = []
    last_move = None
    special_rule_description = "" 

    images = load_images()
    board = chess.Board(None)
    board.clear()

    buttons = {
    "폰": ("P", pygame.Rect(530, HEIGHT - 120, 80, 30)),
    "킹": ("K", pygame.Rect(630, HEIGHT - 120, 80, 30)),
    "퀸": ("Q", pygame.Rect(530, HEIGHT - 80, 80, 30)),
    "룩": ("R", pygame.Rect(630, HEIGHT - 80, 80, 30)),
    "비숍": ("B", pygame.Rect(530, HEIGHT - 40, 80, 30)),
    "나이트": ("N", pygame.Rect(630, HEIGHT - 40, 80, 30)),
    }
    back_button = pygame.Rect(530, HEIGHT - 160, 80, 30)

    running = True
    while running:
        draw_piece_guide_ui(images, buttons, back_button)

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN:
                for _, (symbol, rect) in buttons.items():
                    if rect.collidepoint(event.pos):
                        update_guide_piece(symbol)
                if back_button.collidepoint(event.pos):
                    return

# 체스방법 → 체스기물 : 기물 상태 세팅
def update_guide_piece(symbol):
    global board, puzzle_turn, selected, legal_moves_for_selected, capture_squares, last_move
    global selected_piece_symbol
    
    selected_piece_symbol = symbol
    board.clear()
    puzzle_turn = chess.WHITE
    last_move = None
    capture_squares = []

    if symbol.upper() == "P":
        board.set_piece_at(chess.B2, chess.Piece.from_symbol("P"))
        board.set_piece_at(chess.E4, chess.Piece.from_symbol("P"))

        legal_moves_for_selected = [
            move.to_square for move in board.legal_moves
            if move.from_square in (chess.B2, chess.E4)
        ]
    else:
        center_square = chess.E4
        board.set_piece_at(center_square, chess.Piece.from_symbol(symbol))
        selected = center_square
        legal_moves_for_selected = [
            move.to_square for move in board.legal_moves if move.from_square == center_square
        ]

    selected = None

# 체스방법 → 체스기물 : 전체 시뮬레이션 루프
def draw_piece_guide_ui(images, buttons, back_button):
    screen.fill(BG_COLOR)
    draw_board()
    draw_pieces(images)
    draw_move_dots()

    lines = []

    if selected_piece_symbol:
        desc = PIECE_DESCRIPTIONS.get(selected_piece_symbol, "")
        for paragraph in desc.splitlines():
            wrapped = wrap_text_by_pixel(paragraph, font, 200)
            lines.extend(wrapped)

    x = 520
    y = 40
    for line in lines:
        surface = font.render(line, True, BLACK)
        screen.blit(surface, (x, y))
        y += FONT_SIZE + 6

    for label, (symbol, rect) in buttons.items():
        draw_button_with_text(rect, label, font)

    draw_button_with_text(back_button, "뒤로", font)

    pygame.display.flip()

#특수규칙#

# 체스방법 → 특수규칙 : 보드 UI
def show_special_rule_board():
    global board, selected, legal_moves_for_selected, capture_squares, last_move
    global pending_promotion, special_rule_description, selected_piece_symbol

    board = chess.Board(None)
    selected = None
    legal_moves_for_selected = []
    capture_squares = []
    last_move = None
    pending_promotion = None
    special_rule_description = ""
    selected_piece_symbol = None
    images = load_images()

    buttons = {
        "앙파상": pygame.Rect(530, HEIGHT - 120, 80, 30),
        "프로모션": pygame.Rect(530, HEIGHT - 80, 80, 30),
        "캐슬링": pygame.Rect(530, HEIGHT - 40, 80, 30),
    }
    back_button = pygame.Rect(530, HEIGHT - 160, 80, 30)

    running = True
    while running:
        if pending_promotion is not None:
            from_sq, to_sq = pending_promotion
            handle_promotion(from_sq, to_sq)
            continue

        screen.fill(BG_COLOR)
        draw_board()
        draw_pieces(images)
        draw_move_dots()

        # 설명 텍스트 출력
        if special_rule_description:
            lines = []
            for paragraph in special_rule_description.splitlines():
                wrapped = wrap_text_by_pixel(paragraph, font, 200)
                lines.extend(wrapped)

            y = 10
            
            for line in lines:
                surface = font.render(line, True, BLACK)
                screen.blit(surface, (520, y))
                y += FONT_SIZE + 6


        # 버튼 그리기
        for label, rect in buttons.items():
            draw_button_with_text(rect, label, font)

        draw_button_with_text(back_button, "뒤로", font)

        pygame.display.flip()

        # 이벤트 처리
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN:
                for label, rect in buttons.items():
                    if rect.collidepoint(event.pos):
                        handle_special_rule_selection(label)
                if back_button.collidepoint(event.pos):
                    special_rule_description = ""
                    return
                else:
                    handle_click(event.pos)

# 체스방법 → 특수규칙 : 보드 & 설명 텍스트 설정
def handle_special_rule_selection(label):
    global board, selected, legal_moves_for_selected, capture_squares, last_move
    global special_rule_description, pending_promotion

    board = chess.Board(None)
    selected = None
    legal_moves_for_selected = []
    capture_squares = []
    last_move = None
    pending_promotion = None
    special_rule_description = ""

    if label == "앙파상":
        setup_en_passant()
        special_rule_description = ("폰의 특수규칙\n"
                                    "앙파상 \n"
                                    "상대방의 폰이 2칸을 이동했는데 그 바로 옆 칸에 자신의 폰이 있을 경우 상대방의 폰을 잡을 수 있는 규칙입니다.\n"
                                    "단, 앙파상은 상대가 폰을 2칸 움직인 '직후'에만 잡을 수 있고 그 이후에는 잡을 수 없습니다." )

    elif label == "프로모션":
        setup_promotion()
        special_rule_description = ("폰의 특수규칙\n"
                                    "프로모션 \n"
                                    "폰이 마지막 랭크에 도달하면 퀸, 룩, 비숍, 나이트 중 하나로 승진할 수 있는 규칙입니다.\n")

    elif label == "캐슬링":
        setup_castling()
        special_rule_description = ("킹의 특수규칙\n"
                                    "캐슬링 \n"
                                    "킹이 두 칸 이동하고 룩이 반대편 옆으로 이동하는 규칙입니다.\n"
                                    "캐슬링 조건\n" 
                                    "1. 킹과 룩사이에 다른 기물이 없어야합니다.\n"
                                    "2. 룩과 킹이 한 번도 이동한 적이 없어야 합니다.\n"
                                    "3. 킹이 위치한 칸과 이동할 칸이 체크 상태가 아니어야합니다.\n")

# 체스방법 → 특수규칙 : 앙파상
def setup_en_passant():
    global board, puzzle_turn, selected, legal_moves_for_selected, capture_squares, last_move, move_log
    board.set_fen("rnbqkbnr/pppp1ppp/8/3Pp3/8/8/PPP2PPP/RNBQKBNR w KQkq e6 0 3")
    puzzle_turn = board.turn
    selected = None
    legal_moves_for_selected = []
    capture_squares = []    
    last_move = chess.Move(chess.E7, chess.E5)

# 앙파상 기물선택
def draw_promotion_choice(from_sq, to_sq, color, images):
    choices = ['Q', 'R', 'B', 'N']
    x = 520
    y = 150
    buttons = {}

    for i, piece in enumerate(choices):
        rect = pygame.Rect(x, y + i*40, 80, 30)
        pygame.draw.rect(screen, BUTTON_COLOR, rect)
        pygame.draw.rect(screen, BLACK, rect, 2)
        symbol = piece.upper() if color == chess.WHITE else piece.lower()
        screen.blit(images[symbol], rect.move(25, 0))
        buttons[piece] = rect

    return buttons

# 체스방법 → 특수규칙 : 프로모션
def setup_promotion():
    global board, puzzle_turn, selected, legal_moves_for_selected, capture_squares, last_move, move_log
    board.set_fen("8/5P2/8/8/8/8/8/7k w - - 0 1")
    puzzle_turn = board.turn
    selected = None
    legal_moves_for_selected = []
    capture_squares = []
    last_move = None

# 프로모션 처리
def handle_promotion(from_sq, to_sq):
    global pending_promotion, last_move, move_log, status_message, images

    promoting = True
    color = board.turn
    promo_buttons = draw_promotion_choice(from_sq, to_sq, color, images)

    while promoting:
        screen.fill(BG_COLOR)
        draw_board()
        draw_pieces(images)
        draw_move_dots()

        screen.blit(font.render("승격할 기물을 선택하세요", True, BLACK), (520, 110))

        for piece, rect in promo_buttons.items():
            pygame.draw.rect(screen, BUTTON_COLOR, rect)
            pygame.draw.rect(screen, BLACK, rect, 2)
            symbol = piece.upper() if color == chess.WHITE else piece.lower()
            piece_img = pygame.transform.scale(images[symbol], (32, 32))
            img_x = rect.x + (rect.width - piece_img.get_width()) // 2
            img_y = rect.y + (rect.height - piece_img.get_height()) // 2
            screen.blit(piece_img, (img_x, img_y))

        pygame.display.flip()

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            elif event.type == pygame.MOUSEBUTTONDOWN:
                for piece, rect in promo_buttons.items():
                    if rect.collidepoint(event.pos):
                        move = chess.Move(from_sq, to_sq, promotion=chess.Piece.from_symbol(piece).piece_type)

                        if move in board.legal_moves:
                            san = board.san(move)
                            board.push(move)
                            last_move = move
                            move_log.append(san)

                            # 퍼즐 정답 판정은 퍼즐 화면일 때만
                            if filtered_puzzles and 0 <= current_puzzle_index < len(filtered_puzzles):
                                goal = filtered_puzzles[current_puzzle_index].get("goal", "checkmate")
                                if is_puzzle_success(goal):
                                    status_message = "정답!"
                                    current_type = filtered_puzzles[current_puzzle_index].get("type", "랜덤")
                                    real_index = PUZZLES.index(filtered_puzzles[current_puzzle_index])
                                    if real_index not in solved_history_by_type[current_type]:
                                        solved_history_by_type[current_type].append(real_index)
                                    explanation = filtered_puzzles[current_puzzle_index].get("explanation", "")
                                    if explanation:
                                        status_message += f"\n[해설] {explanation}"
                                else:
                                    status_message = "오답! 다시 시도해 보세요."

                        pending_promotion = None
                        promoting = False

                if back_button_rect and back_button_rect.collidepoint(event.pos):
                    pending_promotion = None
                    promoting = False

        clock.tick(60)

# 체스방법 → 특수규칙 : 캐슬링
def setup_castling():
    global board, puzzle_turn, selected, legal_moves_for_selected, capture_squares, last_move, move_log
    board.set_fen("8/8/8/8/8/8/8/R3K2R w KQ - 0 1")
    puzzle_turn = board.turn
    selected = None
    legal_moves_for_selected = []
    capture_squares = []
    last_move = None

#전술용어#

# 체스방법 → 전술용어 보여주는 함수
def show_tactic_guide_board():
    
    global board, special_rule_description, last_move, selected
    global legal_moves_for_selected, capture_squares, pending_promotion
    global move_log, puzzle_turn, selected_piece_symbol, status_message
    
    special_rule_description = ""
    last_move = None
    selected = None
    legal_moves_for_selected = []
    capture_squares = []
    pending_promotion = None
    move_log = []
    status_message = ""
    selected_piece_symbol = None
    puzzle_turn = None
    
    board = chess.Board(None)
    board.clear()
    
    # 버튼 구성
    buttons = {
        "체크": ("check", pygame.Rect(530, HEIGHT - 120, 95, 30)),
        "체크메이트": ("checkmate", pygame.Rect(630, HEIGHT - 120, 105, 30)),
        "핀": ("pin", pygame.Rect(530, HEIGHT - 80, 95, 30)),
        "스큐어": ("skewer", pygame.Rect(630, HEIGHT - 80, 105, 30)),
        "포크": ("fork", pygame.Rect(530, HEIGHT - 40, 95, 30)),
        "스테일메이트": ("stalemate", pygame.Rect(630, HEIGHT - 40, 105, 30))
    }
    back_button = pygame.Rect(530, HEIGHT - 160, 95, 30)

    running = True
    while running:
        draw_tactic_guide_ui(images, buttons, back_button)

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN:
                for label, (_, rect) in buttons.items():
                    if rect.collidepoint(event.pos):
                        load_tactic_board(label)
                if back_button.collidepoint(event.pos):
                    return

# 체스방법 → 전술용어 그리기 함수
def draw_tactic_guide_ui(images, buttons, back_button):
    screen.fill(BG_COLOR)
    draw_board()
    draw_pieces(images)

    # 설명 텍스트
    if special_rule_description:
        y = 10
        for paragraph in special_rule_description.splitlines():
            wrapped_lines = wrap_text_by_pixel(paragraph, font, 200)
            for line in wrapped_lines:
                text_surface = font.render(line, True, BLACK)
                screen.blit(text_surface, (520, y))
                y += FONT_SIZE + 6


    # 버튼들
    for label, (_, rect) in buttons.items():
        draw_button_with_text(rect, label, font)

    # 뒤로 버튼
    draw_button_with_text(back_button, "뒤로", font)

    pygame.display.flip()

# 체스방법 → 전술용어 설명 함수
def load_tactic_board(tactic_name):
    global board, special_rule_description, last_move, selected
    global legal_moves_for_selected, capture_squares, pending_promotion
    global move_log, puzzle_turn, selected_piece_symbol, status_message
    
    last_move = None
    selected = None
    legal_moves_for_selected = []
    capture_squares = []
    pending_promotion = None
    move_log = []
    status_message = ""
    selected_piece_symbol = None
    special_rule_description = ""
    puzzle_turn = None

    board = chess.Board(None)
    board.clear()

    tactic_data = {
        "체크": {
            "fen": "6k1/8/7p/8/8/1B6/8/6K1 b - - 1 1",
            "desc": "체크\n킹이 다른 체스 기물에 의해 공격받는것을 체크라고 합니다.\n체크를 당한 상대는 무조건 체크 상태에서 벗어나기 위한 수를 두어야 합니다.\n보드에서는 백 비숍이 흑 킹에게 체크를 걸었습니다."
        },
        "체크메이트": {
            "fen": "7r/3k2r1/8/8/8/7K/8/8 w - - 2 2",
            "desc": "체크메이트\n킹이 어떤 수를 두어도 체크 상태에서 벗어날 수 없는 상황을 체크메이트라고 합니다.\n체크메이트에 성공 시, 그 즉시 승리하게 됩니다. \n보드에서는 흑 룩이 백 킹을 체크메이트 시켰습니다."
        },
        "핀": {
            "fen": "8/3k4/8/5r2/6B1/8/8/2K5 b - - 1 1",
            "desc": "핀\n앞에 있는 기물이 공격받고 있는 상황에서 뒤에 있는 높은 가치의 기물 때문에 움직이지 못하는 것을 말합니다.\n뒤의 기물이 킹일 경우 앞의 기물을 움직일 수 없습니다. \n보드에서는 백 비숍이 흑 룩을 핀에 걸었습니다."
        },
        "스큐어": {
            "fen": "8/8/1k6/8/8/8/r2K3Q/8 b - - 1 1",
            "desc": "스큐어\n앞에 있는 가치가 높은 기물이 움직이면서 뒤에 있는 다른 기물이 잡히는 경우를 말합니다.\n보드에서는 흑 룩이 백 킹에게 스큐어를 걸었습니다."
        },
        "포크": {
            "fen": "r3k3/2N5/8/8/8/8/8/4K3 b - - 0 1",
            "desc": "포크\n하나의 기물로 두 개 이상의 기물을 공격하는 것을 포크라고 합니다.\n보드에서는 백 나이트가 흑 킹과 흑 룩에게 포크를 걸었습니다."
        },
        "스테일메이트": {
            "fen": "k1b3R1/8/1Q6/7p/7P/8/8/3K4 b - - 0 1",
            "desc": "스테일메이트\n자신의 차례에 킹이 체크 상태가 아니지만 어떤 수도 둘 수 없는 상태입니다. \n체크메이트와 달리 무승부가 됩니다. \n보드에서는 흑 비숍이 백 룩에 핀에 걸려있고, 흑이 둘 수 있는 수가 없으므로 스테일메이트입니다." 
        }
    }

    if tactic_name in tactic_data:
        board.set_fen(tactic_data[tactic_name]["fen"])
        special_rule_description = tactic_data[tactic_name]["desc"]

##연습문제##

# 전체 인터페이스를 그리는 함수
def draw_interface(images):
    screen.fill(BG_COLOR)
    draw_board()
    draw_pieces(images)
    draw_move_dots()
    draw_move_log()
    draw_buttons()

    puzzle_type = filtered_puzzles[current_puzzle_index].get("type", "랜덤")
    if puzzle_type:
        type_text = font.render(f"[유형] {puzzle_type}", True, (0, 100, 0))
        screen.blit(type_text, (518, HEIGHT - 140))

    if current_puzzle_type == "랜덤":
        puzzle_num = current_random_index + 1
        total = len(filtered_puzzles)
    else:
        puzzle_num = full_puzzle_order.index(current_puzzle_index) + 1
        total = len(full_puzzle_order)

    puzzle_text = font.render(f"퍼즐 {puzzle_num} / {total}", True, BLACK)
    screen.blit(puzzle_text, (518, HEIGHT - 110))

# 체스판을 그리는 함수
def draw_board():
    files = 'abcdefgh'
    ranks = '87654321'
    is_flipped = puzzle_turn == chess.BLACK

    for row in range(8):
        for col in range(8):
            display_row = row if not is_flipped else 7 - row
            display_col = col if not is_flipped else 7 - col
            square = chess.square(display_col, 7 - display_row)

            color = WHITE if (row + col) % 2 == 0 else BROWN
            if last_move and (square == last_move.from_square or square == last_move.to_square):
                color = HIGHLIGHT_COLOR

            rect = pygame.Rect(col*SQUARE_SIZE, row*SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE)
            pygame.draw.rect(screen, color, rect)

            if col == 0:
                rank_label = ranks[display_row]
                label = font.render(rank_label, True, (50, 50, 50))
                screen.blit(label, (2, row*SQUARE_SIZE + 2))

            if row == 7:
                file_label = files[display_col]
                label = font.render(file_label, True, (50, 50, 50))
                x = col*SQUARE_SIZE + SQUARE_SIZE - label.get_width() - 2
                y = HEIGHT - label.get_height() - 2
                screen.blit(label, (x, y))

# 퍼즐 유형 선택 함수
def show_puzzle_category_screen():
    global back_button_rect, filtered_puzzles
    global puzzle_order, full_puzzle_order, current_puzzle_index, current_puzzle_type

    # 초기화
    filtered_puzzles.clear()
    puzzle_order.clear()
    current_puzzle_type = None
    current_puzzle_index = 0

    categories = [
        "1수 체크메이트", "핀", "포크",
        "공짜 기물 잡기", "스큐어", "랜덤"
    ]

    buttons = {}
    start_x, start_y = 150, 100
    button_width, button_height = 180, 40
    gap_y = 60

    for i, category in enumerate(categories):
        x = start_x + (i % 2) * (button_width + 60)
        y = start_y + (i // 2) * gap_y
        rect = pygame.Rect(x, y, button_width, button_height)
        buttons[category] = rect

    back_button_rect = pygame.Rect(20, HEIGHT - 50, 80, 30)

    while True:
        screen.fill(BG_COLOR)
        title = font.render("퍼즐 유형 선택", True, BLACK)
        screen.blit(title, (WIDTH // 2 - title.get_width() // 2, 30))

        for label, rect in buttons.items():
            draw_button_with_text(rect, label, font)

        draw_button_with_text(back_button_rect, "뒤로", font)

        pygame.display.flip()

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            elif event.type == pygame.MOUSEBUTTONDOWN:
                if back_button_rect.collidepoint(event.pos):
                    return  # 시작 화면으로 돌아감

                for label, rect in buttons.items():
                    if rect.collidepoint(event.pos):
                        current_puzzle_type = label
                        filtered_puzzles = get_filtered_puzzles_by_type(label)

                        if not filtered_puzzles:
                            print("[INFO] 선택된 퍼즐이 없습니다.")
                            return

                        # 퍼즐 순서 설정
                        puzzle_order = list(range(len(filtered_puzzles)))
                        random.shuffle(puzzle_order)
                        full_puzzle_order = puzzle_order.copy()

                        if not puzzle_order:
                            print("[ERROR] puzzle_order가 비어 있습니다.")
                            return
                        
                        if current_puzzle_type == "랜덤":
                            global current_random_index
                            current_random_index = 0

                        # 첫 퍼즐 시작
                        current_puzzle_index = puzzle_order.pop(0)
                        start_puzzle_game()
                        return

        clock.tick(60)

# 퍼즐 유형 랜덤 선택 함수
def get_filtered_puzzles_by_type(puzzle_type):
    if puzzle_type == "랜덤":
        # FEN 중복 제거
        seen_fens = set()
        unique_puzzles = []
        for p in PUZZLES:
            fen = p.get("fen")
            if fen not in seen_fens:
                seen_fens.add(fen)
                unique_puzzles.append(p)

        return random.sample(unique_puzzles, min(20, len(unique_puzzles)))
    else:
        return [p for p in PUZZLES if p.get("type") == puzzle_type]

# 기물을 그리는 함수
def draw_pieces(images):
    is_flipped = puzzle_turn == chess.BLACK
    if board is None:
        return
    for square in chess.SQUARES:
        piece = board.piece_at(square)
        if piece:
            rank = chess.square_rank(square)
            file = chess.square_file(square)
            display_row = 7 - rank if not is_flipped else rank
            display_col = file if not is_flipped else 7 - file
            x = display_col * SQUARE_SIZE
            y = display_row * SQUARE_SIZE
            screen.blit(images[piece.symbol()], pygame.Rect(x, y, SQUARE_SIZE, SQUARE_SIZE))

# 퍼즐 정답 비교 함수
def was_correct_move():
    if not move_log or "solution" not in filtered_puzzles[current_puzzle_index]:
        return False
    expected = filtered_puzzles[current_puzzle_index]["solution"]
    actual = move_log[-1]
    return expected.replace("+", "").replace("x", "") in actual.replace("+", "").replace("x", "")

# 퍼즐 정답 여부 판단 함수
def is_puzzle_success(goal):
    puzzle = filtered_puzzles[current_puzzle_index]

    # 우선 solution 기반 판정
    if "solution" in puzzle:
        return was_correct_move()

    # goal 기반 판정 (solution이 없을 경우)
    goal = puzzle.get("goal", "checkmate")
    if goal == "checkmate":
        return board.is_checkmate()

    return False

# 기물이 갈 수 있는 곳을 표시하는 함수 (잡을 수 있는 곳은 빨간색)
def draw_move_dots():
    is_flipped = puzzle_turn == chess.BLACK
    for square in legal_moves_for_selected:
        rank = chess.square_rank(square)
        file = chess.square_file(square)
        display_row = 7 - rank if not is_flipped else rank
        display_col = file if not is_flipped else 7 - file
        cx = display_col * SQUARE_SIZE + SQUARE_SIZE // 2
        cy = display_row * SQUARE_SIZE + SQUARE_SIZE // 2
        radius = SQUARE_SIZE // 10
        if square not in capture_squares:
            pygame.draw.circle(screen, DOT_COLOR, (cx, cy), radius)
        else:
            pygame.draw.circle(screen, ATTACK_DOT_COLOR, (cx, cy), radius)

# 기보 및 버튼을 그리는 함수
def draw_move_log():
    pygame.draw.rect(screen, BG_COLOR, pygame.Rect(512, 0, MOVE_LOG_WIDTH, HEIGHT))
    turn_text = "백 차례" if puzzle_turn == chess.WHITE else "흑 차례"
    screen.blit(font.render(turn_text, True, (0, 100, 200)), (518, 10))

    y = 40
    for move in move_log:
        screen.blit(font.render(move, True, BLACK), (518, y))
        y += FONT_SIZE + 4

    # 기보 ↔ 메시지 사이 간격
    y += 10

    if status_message:
        lines = status_message.split('\n')
        for i, line in enumerate(lines):
            if line.startswith("[해설]"):
                y += 10
                # 해설 타이틀 출력
                screen.blit(font.render("[해설]", True, BLACK), (518, y))
                y += FONT_SIZE + 10  # 제목과 본문 사이 간격

                # 해설 본문 추출 및 줄바꿈
                explanation_text = line.replace("[해설] ", "")
                wrapped_lines = wrap_text_by_pixel(explanation_text, font, 200)
                for wrapped in wrapped_lines:
                    screen.blit(font.render(wrapped, True, BLACK), (518, y))
                    y += FONT_SIZE + 4

            elif line.startswith("[힌트]"):
                hint_text = line.replace("[힌트] ", "")
                wrapped_lines = wrap_text_by_pixel(hint_text, font, 200)
                y += 10
                screen.blit(font.render("[힌트]", True, (200, 90, 0)), (518, y))
                y += FONT_SIZE + 6
                for wrapped in wrapped_lines:
                    screen.blit(font.render(wrapped, True, (200, 90, 0)), (518, y))
                    y += FONT_SIZE + 4

            else:
                wrapped_lines = wrap_text_by_pixel(line, font, 200)
                for wrapped in wrapped_lines:
                    screen.blit(font.render(wrapped, True, (200, 0, 0)), (518, y))
                    y += FONT_SIZE + 4

# 다시하기,뒤로,이전,다음 버튼을 그리는 함수
def draw_buttons():
    draw_button_with_text(reset_button_rect, "다시하기", font)
    draw_button_with_text(back_button_rect, "뒤로", font)
    draw_button_with_text(prev_button_rect, "이전", font)
    draw_button_with_text(next_button_rect, "다음", font)

# 다시하기/이전/다음/뒤로 버튼 처리
def handle_common_buttons(event):
    global current_puzzle_index, current_random_index, puzzle_order, filtered_puzzles, current_puzzle_type, status_message

    if reset_button_rect.collidepoint(event.pos):
        reset_game_state()
        status_message = ""
        return True


    elif prev_button_rect.collidepoint(event.pos):
        if current_puzzle_type == "랜덤":
            if current_random_index > 0:
                current_random_index -= 1
                current_puzzle_index = current_random_index
                reset_game_state()
        else:
            if used_puzzle_order:
                puzzle_order.insert(0, current_puzzle_index)
                current_puzzle_index = used_puzzle_order.pop()
                reset_game_state()
            if not used_puzzle_order:
                return True


    elif next_button_rect.collidepoint(event.pos):
        if "정답!" not in status_message:
            return True

        if current_puzzle_type == "랜덤":
            if current_random_index + 1 < len(filtered_puzzles):
                current_random_index += 1
                current_puzzle_index = current_random_index
                reset_game_state()
        else:
            if puzzle_order:
                used_puzzle_order.append(current_puzzle_index)
                current_puzzle_index = puzzle_order.pop(0)
                reset_game_state()


    elif back_button_rect.collidepoint(event.pos):
        reset_game_state()
        filtered_puzzles.clear()
        puzzle_order.clear()
        full_puzzle_order.clear()
        current_puzzle_index = 0
        current_puzzle_type = None
        current_random_index = 0
        
        return True

    return False

# 사각형 클릭 시 해당 위치의 square 반환 함수
def get_square(pos):
    x, y = pos
    if x >= 512 or y >= 512:
        return None
    col = x // SQUARE_SIZE
    row = y // SQUARE_SIZE
    is_flipped = puzzle_turn == chess.BLACK
    display_col = col if not is_flipped else 7 - col
    display_row = 7 - row if not is_flipped else row
    return chess.square(display_col, display_row)

# 클릭 이벤트 처리 함수
def handle_click(pos):
    global selected, legal_moves_for_selected, last_move, move_log
    global capture_squares, status_message, current_puzzle_index
    global pending_promotion

    # 클릭 좌표를 체스보드의 square로 변환 (보드 밖 클릭 시 None 반환)
    square = get_square(pos)
    if square is None or pending_promotion:
        return  # 보드 밖 클릭 또는 프로모션 대기 상태일 경우 클릭 무시

    # 이미 정답 또는 오답 메시지가 떠 있는 상태라면 추가 클릭 차단
    if status_message in ["정답!", "오답! 다시 시도해 보세요."]:
        return

    # 같은 칸을 다시 클릭했을 경우 선택 해제
    if selected == square:
        selected, legal_moves_for_selected, capture_squares = None, [], []
        return

    clicked_square = get_square(pos)
    piece = board.piece_at(clicked_square)

    if selected is not None:
        # 선택된 말이 있는 상태에서
        if clicked_square == selected:
            # 같은 칸 클릭 → 선택 해제
            selected, legal_moves_for_selected, capture_squares = None, [], []

        elif piece and piece.color == puzzle_turn:
            # 아군 기물을 클릭 → 선택 대상 변경 + 이동 가능 칸 갱신
            selected = clicked_square
            legal_moves_for_selected = []
            capture_squares = []
            for move in board.legal_moves:
                if move.from_square == selected:
                    legal_moves_for_selected.append(move.to_square)
                    if board.is_capture(move):
                        capture_squares.append(move.to_square)

        elif clicked_square in legal_moves_for_selected:
            # 합법적인 목적지를 클릭한 경우 → 실제 이동 처리
            move = chess.Move(selected, clicked_square)
            piece = board.piece_at(selected)

            # 프로모션 대상 칸(0 또는 7 rank)일 경우 프로모션 선택창으로 넘김
            if piece and piece.piece_type == chess.PAWN and chess.square_rank(clicked_square) in [0, 7]:
                pending_promotion = (selected, clicked_square)
                selected, legal_moves_for_selected, capture_squares = None, [], []
                return

            # 일반 이동일 경우 handle_move로 연결
            handle_move(move)

            # 선택 상태 및 점 표시 초기화
            selected, legal_moves_for_selected, capture_squares = None, [], []

    elif piece and piece.color == puzzle_turn:
        # 선택된 말이 없는 상태에서 아군 기물 클릭 시 → 선택 및 이동 가능 칸 계산
        selected = clicked_square
        legal_moves_for_selected = []
        capture_squares = []
        for move in board.legal_moves:
            if move.from_square == selected:
                legal_moves_for_selected.append(move.to_square)
                if board.is_capture(move):
                    capture_squares.append(move.to_square)

    # 프로모션 대상일 경우 → pending_promotion 세팅
    if selected is not None:
        piece = board.piece_at(selected)
        if piece and piece.piece_type == chess.PAWN and chess.square_rank(square) in [0, 7]:
            for piece_type in [chess.QUEEN, chess.ROOK, chess.BISHOP, chess.KNIGHT]:
                promo_move = chess.Move(selected, square, promotion=piece_type)
                if promo_move in board.legal_moves:
                    pending_promotion = (selected, square)
                    selected, legal_moves_for_selected, capture_squares = None, [], []
                    return

# 이동 이벤트 처리 함수
def handle_move(move):
    global selected, legal_moves_for_selected, capture_squares
    global last_move, move_log, status_message

    if move in board.legal_moves:
        san = board.san(move)
        board.push(move)
        last_move = move
        move_log.append(san)
        selected, legal_moves_for_selected, capture_squares = None, [], []

        if filtered_puzzles and 0 <= current_puzzle_index < len(filtered_puzzles):
            goal = filtered_puzzles[current_puzzle_index].get("goal", "checkmate")
            puzzle_type = filtered_puzzles[current_puzzle_index].get("type", "전술")
            explanation = filtered_puzzles[current_puzzle_index].get("explanation", "")
            if is_puzzle_success(goal):
                status_message = "정답!"

                real_puzzle = filtered_puzzles[current_puzzle_index]
                real_index = PUZZLES.index(real_puzzle)
                real_type = real_puzzle.get("type", "랜덤")

                explanation = real_puzzle.get("explanation", "")
                if explanation:
                    status_message += f"\n[해설] {explanation}"

                if real_index not in solved_history_by_type[real_type]:
                    solved_history_by_type[real_type].append(real_index)
            else:
                hint_text = TACTIC_HINTS.get(puzzle_type, f"'{puzzle_type}' 전술을 사용해보세요!")
                status_message = (
                    f"오답! 다시 시도해 보세요.\n"
                    f"[힌트] {hint_text}"
                )

# 일반 기물 클릭 처리
def start_puzzle_game():
    global reset_button_rect, back_button_rect, prev_button_rect, next_button_rect
    global images, current_puzzle_index, pending_promotion

    images = load_images()

    reset_button_rect = pygame.Rect(520, HEIGHT - 80, 100, 25)
    back_button_rect = pygame.Rect(625, HEIGHT - 80, 100, 25)
    prev_button_rect = pygame.Rect(520, HEIGHT - 40, 100, 25)
    next_button_rect = pygame.Rect(625, HEIGHT - 40, 100, 25)

    reset_game_state()
    running = True

    while running:

        if pending_promotion is not None:
            from_sq, to_sq = pending_promotion
            handle_promotion(from_sq, to_sq)
            continue
        
        screen.fill(BG_COLOR)
        draw_interface(images)
        pygame.display.flip()

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
                pygame.quit()
                sys.exit()

            elif event.type == pygame.MOUSEBUTTONDOWN:
                if handle_common_buttons(event):
                    if back_button_rect.collidepoint(event.pos):
                        running = False
                        show_puzzle_category_screen()
                        return
                else:
                    handle_click(event.pos)

        clock.tick(60)

    pygame.quit()
    sys.exit()

# 퍼즐 상태 초기화 함수
def reset_game_state():
    global board, selected, legal_moves_for_selected, capture_squares
    global last_move, move_log, pending_promotion, status_message
    global filtered_puzzles, current_puzzle_index, puzzle_turn

    selected = None
    legal_moves_for_selected = []
    capture_squares = []
    last_move = None
    move_log = []
    pending_promotion = None
    status_message = ""

    # 퍼즐 정보가 유효한 경우 보드 세팅
    if filtered_puzzles and 0 <= current_puzzle_index < len(filtered_puzzles):
        fen = filtered_puzzles[current_puzzle_index].get("fen", chess.STARTING_FEN)
        board = chess.Board(fen)
        puzzle_turn = board.turn
    else:
        board = chess.Board()
        puzzle_turn = board.turn
    
# 메인 실행 함수
def main():
    global screen, font, clock, images

    pygame.init()
    screen = pygame.display.set_mode((WIDTH, HEIGHT))
    pygame.display.set_caption("체스 입문자용 가이드북")
    font = pygame.font.Font(pygame.font.match_font("nanumgothic", True), FONT_SIZE)
    clock = pygame.time.Clock()
    images = load_images()
    while True:
        show_start_screen()

# 프로그램 시작
if __name__ == "__main__":
    main()
